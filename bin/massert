#!/usr/bin/env ruby

# BIN_NAME           = "massert"
# TEST_DIR           = "test"
# TEST_FILE_SUFFIXES = ["_test.rb"]
# DEFAULT_TEST_CMD   = "MINITEST_REPORTER=ProgressReporter ./bin/rake test"
# VERBOSE_TEST_CMD   = "MINITEST_REPORTER=SpecReporter ./bin/rake test"
# SEED_ENV_VAR_NAME  = "SEED"
# ENV_VARS           = "USE_SIMPLE_COV=0"

require 'benchmark'
require 'set'

# https://github.com/redding/a-test-runner.rb
module ATestRunner
  VERSION = "1.0.0"

  # update these as needed for your test setup
  BIN_NAME           = "massert"
  TEST_DIR           = "test"
  TEST_FILE_SUFFIXES = ["_test.rb"]
  DEFAULT_TEST_CMD   = "MINITEST_REPORTER=ProgressReporter ./bin/rails test"
  VERBOSE_TEST_CMD   = "MINITEST_REPORTER=SpecReporter ./bin/rails test"
  SEED_ENV_VAR_NAME  = "SEED"
  ENV_VARS           = "USE_SIMPLE_COV=0"

  class Config
    def self.settings(*items)
      items.each do |item|
        define_method(item) do |*args|
          if !(value = args.size > 1 ? args : args.first).nil?
            instance_variable_set("@#{item}", value)
          end
          instance_variable_get("@#{item}")
        end
      end
    end

    attr_reader :stdout, :bin_name, :test_dir, :test_file_suffixes
    attr_reader :default_test_cmd, :verbose_test_cmd
    attr_reader :seed_env_var_name, :env_vars

    settings :seed_value, :changed_only, :changed_ref
    settings :verbose, :dry_run, :list, :debug

    def initialize(stdout = nil)
      @stdout = stdout || $stdout

      @bin_name           = BIN_NAME
      @test_dir           = TEST_DIR
      @test_file_suffixes = TEST_FILE_SUFFIXES
      @default_test_cmd   = DEFAULT_TEST_CMD
      @verbose_test_cmd   = VERBOSE_TEST_CMD
      @seed_env_var_name  = SEED_ENV_VAR_NAME
      @env_vars           = ENV_VARS

      # cli option settings
      @seed_value   = begin; srand; srand % 0xFFFF; end.to_i
      @changed_only = false
      @changed_ref  = ''
      @verbose      = false
      @dry_run      = false
      @list         = false
      @debug        = false
    end

    def apply(settings)
      settings.keys.each do |name|
        if !settings[name].nil? && self.respond_to?(name.to_s)
          self.send(name.to_s, settings[name])
        end
      end
    end
  end

  class CLI
    def initialize(*argv)
      @argv = argv
      @clirb = CLIRB.new do
        option 'seed_value', 'use a given seed to run tests', {
          :abbrev => 's', :value => Integer
        }
        option 'changed_only', 'only run test files with changes', {
          :abbrev => 'c'
        }
        option 'changed_ref', 'reference for changes, use with `-c` opt', {
          :abbrev => 'r', :value => ''
        }
        option 'verbose', 'output verbose runtime test info', {
          :abbrev => 'v'
        }
        option 'dry_run', 'output the test command to $stdout'
        option 'list', 'list test files on $stdout', {
          :abbrev => 'l'
        }
        # show loaded test files, cli err backtraces, etc
        option 'debug', 'run in debug mode', {
          :abbrev => 'd'
        }
      end
    end

    def run
      begin
        @clirb.parse!(@argv)
        Runner.new(ATestRunner.config, @clirb.args, @clirb.opts).run
      rescue CLIRB::HelpExit
        ATestRunner.config.stdout.puts help
      rescue CLIRB::VersionExit
        ATestRunner.config.stdout.puts ATestRunner::VERSION
      rescue CLIRB::Error => exception
        ATestRunner.config.stdout.puts "#{exception.message}\n\n"
        ATestRunner.config.stdout.puts  ATestRunner.config.debug ? exception.backtrace.join("\n") : help
        exit(1)
      rescue StandardError => exception
        ATestRunner.config.stdout.puts "#{exception.class}: #{exception.message}"
        ATestRunner.config.stdout.puts exception.backtrace.join("\n")
        exit(1)
      end
      exit(0)
    end

    def help
      "Usage: #{ATestRunner.config.bin_name} [options] [TESTS]\n\n"\
      "Options:"\
      "#{@clirb}"
    end
  end

  class Runner
    attr_reader :config, :cmd_str

    def initialize(config, test_paths, test_options)
      @config = config
      self.config.apply(test_options)

      paths = test_paths.empty? ? [*self.config.test_dir] : test_paths
      @test_files = lookup_test_files(paths)

      if self.config.debug
        self.config.stdout.puts ATestRunner.debug_msg("#{@test_files.size} Test files:")
        @test_files.each do |fa|
          self.config.stdout.puts ATestRunner.debug_msg("  #{fa}")
        end
      end

      @cmd_str = "#{cmd_str_env} #{cmd_str_cmd} #{@test_files.join(" ")}"
      if self.config.debug && !@test_files.empty?
        self.config.stdout.puts ATestRunner.debug_msg("Test command:")
        self.config.stdout.puts ATestRunner.debug_msg("  #{@cmd_str}")
      end
    end

    def run
      if execute_cmd_str?
        system(self.cmd_str)
      else
        self.config.stdout.puts @test_files.join("\n") if self.config.list
        self.config.stdout.puts self.cmd_str           if self.config.dry_run
      end
    end

    private

    def execute_cmd_str?
      !@test_files.empty? && !self.config.dry_run && !self.config.list
    end

    def cmd_str_env
      "#{self.config.env_vars} "\
        "#{self.config.seed_env_var_name}=#{self.config.seed_value}"
    end

    def cmd_str_cmd
      self.config.verbose ? self.config.verbose_test_cmd : self.config.default_test_cmd
    end

    def lookup_test_files(test_paths)
      files = nil

      if self.config.changed_only
        result = nil
        ATestRunner.bench('Lookup changed test files') do
          result = changed_test_files(test_paths)
        end
        files = result.files
        if config.debug
          self.config.stdout.puts ATestRunner.debug_msg("  `#{result.cmd}`")
        end
      else
        ATestRunner.bench('Lookup test files') do
          files = filtered_test_files(test_paths)
        end
      end

      files
    end

    def changed_test_files(test_paths)
      result = GitChangedFiles.new(self.config, test_paths)
      ChangedResult.new(result.cmd, filtered_test_files(result.files))
    end

    def filtered_test_files(test_paths)
      test_paths.
        inject(Set.new) { |files, path|
          files +=
            if is_single_test?(path)
              [path]
            else
              globbed_test_files(path)
            end
        }.
        sort
    end

    def globbed_test_files(test_path)
      pwd = Dir.pwd
      path = File.expand_path(test_path, pwd)
      (Dir.glob("#{path}*") + Dir.glob("#{path}*/**/*")).
        select{ |p| is_test_file?(p) }.
        map{ |p| p.gsub("#{pwd}/", '') }
    end

    def is_single_test?(file_line_path)
      file, line = (file_line_path.to_s.match(/(^[^\:]*)\:*(\d*).*$/) || [])[1..2]
      !line.empty? && is_test_file?(file)
    end

    def is_test_file?(path)
      self.config.test_file_suffixes.inject(false) do |result, suffix|
        result || path =~ /#{suffix}$/
      end
    end
  end

  ChangedResult = Struct.new(:cmd, :files)

  module GitChangedFiles
    def self.cmd(config, test_paths)
      [ "git diff --no-ext-diff --name-only #{config.changed_ref}", # changed files
        "git ls-files --others --exclude-standard"                  # added files
      ].map{ |c| "#{c} -- #{test_paths.join(' ')}" }.join(' && ')
    end

    def self.new(config, test_paths)
      cmd = self.cmd(config, test_paths)
      ChangedResult.new(cmd, `#{cmd}`.split("\n"))
    end
  end

  module RoundedMillisecondTime
    ROUND_PRECISION = 3
    ROUND_MODIFIER = 10 ** ROUND_PRECISION
    def self.new(time_in_seconds)
      (time_in_seconds * 1000 * ROUND_MODIFIER).to_i / ROUND_MODIFIER.to_f
    end
  end

  class CLIRB  # Version 1.0.0, https://github.com/redding/cli.rb
    Error    = Class.new(RuntimeError);
    HelpExit = Class.new(RuntimeError); VersionExit = Class.new(RuntimeError)
    attr_reader :argv, :args, :opts, :data

    def initialize(&block)
      @options = []; instance_eval(&block) if block
      require 'optparse'
      @data, @args, @opts = [], [], {}; @parser = OptionParser.new do |p|
        p.banner = ''; @options.each do |o|
          @opts[o.name] = o.value; p.on(*o.parser_args){ |v| @opts[o.name] = v }
        end
        p.on_tail('--version', ''){ |v| raise VersionExit, v.to_s }
        p.on_tail('--help',    ''){ |v| raise HelpExit,    v.to_s }
      end
    end

    def option(*args); @options << Option.new(*args); end
    def parse!(argv)
      @args = (argv || []).dup.tap do |args_list|
        begin; @parser.parse!(args_list)
        rescue OptionParser::ParseError => err; raise Error, err.message; end
      end; @data = @args + [@opts]
    end
    def to_s; @parser.to_s; end
    def inspect
      "#<#{self.class}:#{'0x0%x' % (object_id << 1)} @data=#{@data.inspect}>"
    end

    class Option
      attr_reader :name, :opt_name, :desc, :abbrev, :value, :klass, :parser_args

      def initialize(name, *args)
        settings, @desc = args.last.kind_of?(::Hash) ? args.pop : {}, args.pop || ''
        @name, @opt_name, @abbrev = parse_name_values(name, settings[:abbrev])
        @value, @klass = gvalinfo(settings[:value])
        @parser_args = if [TrueClass, FalseClass, NilClass].include?(@klass)
          ["-#{@abbrev}", "--[no-]#{@opt_name}", @desc]
        else
          ["-#{@abbrev}", "--#{@opt_name} #{@opt_name.upcase}", @klass, @desc]
        end
      end

      private

      def parse_name_values(name, custom_abbrev)
        [ (processed_name = name.to_s.strip.downcase), processed_name.gsub('_', '-'),
          custom_abbrev || processed_name.gsub(/[^a-z]/, '').chars.first || 'a'
        ]
      end
      def gvalinfo(v); v.kind_of?(Class) ? [nil,v] : [v,v.class]; end
      # def gklass(k); k == Fixnum ? Integer : k; end
    end
  end

  # ATestRunner

  def self.config
    @config ||= Config.new
  end

  def self.debug?(argv)
    !!argv.find{ |a| (a =~ /-[a-c,e-z]*d/ && a != "--dry-run") || a == "--debug" }
  end

  def self.debug_msg(msg)
    "[DEBUG] #{msg}"
  end

  def self.debug_start_msg(msg)
    debug_msg("#{msg}...".ljust(30))
  end

  def self.debug_finish_msg(time_in_ms)
    " (#{time_in_ms} ms)"
  end

  def self.bench(start_msg, &block)
    if !ATestRunner.config.debug
      block.call; return
    end
    self.config.stdout.print debug_start_msg(start_msg)
    RoundedMillisecondTime.new(Benchmark.measure(&block).real).tap do |time_in_ms|
      self.config.stdout.puts debug_finish_msg(time_in_ms)
    end
  end
end

unless ENV['A_TEST_RUNNER_DISABLE_RUN']
  ATestRunner.config.debug ATestRunner.debug?(ARGV)

  cli = nil
  ATestRunner.bench('CLI init and parse'){ cli = ATestRunner::CLI.new(*ARGV) }
  cli.run
end
